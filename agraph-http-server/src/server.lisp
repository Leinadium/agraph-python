(in-package :agraph-http-server)

(defclass catalog ()
  ((cache :reader @cache)
   (lock :initform (mp:make-process-lock) :reader @lock)
   (directory :initarg :directory :reader @directory)
   (open-stores :initform (make-hash-table :test 'equal) :reader @open-stores)
   (open-environments :initform (make-hash-table :test 'equal) :reader @open-environments)
   (username :initform nil :initarg :username :reader @username)
   (password :initform nil :initarg :password :reader @password)))

(defmacro with-catalog-cache ((catalog &optional write-p) &body body)
  `(flet ((body () ,@body))
     (let* ((catalog ,catalog)
            (*allegrocache* (@cache catalog)))
       (mp:with-process-lock ((@lock catalog))
         (rollback)
         ,(if write-p '(prog1 (body) (commit)) '(body))))))

(defmethod initialize-instance :after ((catalog catalog) &key cache-file &allow-other-keys)
  (assert (@directory catalog))
  (setf (slot-value catalog 'directory) (directorify-path (@directory catalog)))
  (unless (probe-file (@directory catalog))
    (make-directory (@directory catalog)))
  (setf (slot-value catalog 'cache)
        (let (*allegrocache*) (open-file-database (or cache-file (namestring (merge-pathnames "_catalogdata" (@directory catalog))))
                                                  :if-does-not-exist :create))))

(defun close-catalog (catalog)
  (close-database :db (@cache catalog))
  (maphash (lambda (name db)
             (declare (ignore name))
             (close-triple-store db))
           (@open-stores catalog)))

(defclass open-store ()
  ((db :initarg :db :reader @db)
   (name :initarg :name :reader @name)
   (reasoning-db :initarg :reasoning-db :reader @reasoning-db)))

(defun store-file (name catalog)
  (merge-pathnames (format nil "~a/" name) (@directory catalog)))  

(defun set-store-open (catalog db name)
  (setf (gethash name (@open-stores catalog))
        (make-instance 'open-store :db db :name name
                       :reasoning-db (db-apply-reasoner db 'rdfs++-reasoner name))))

(defun list-stores (catalog)
  (loop :for sub :in (directory (@directory catalog) :directories-are-files nil)
        :when (and (not (pathname-name sub)) (probe-file (merge-pathnames #p"metadata" sub)))
        :collect (directory-name sub)))

(defun get-store (catalog name)
  (or (gethash name (@open-stores catalog))
      (let ((file (store-file name catalog)))
        (and (not (match-re "[/\\\\]" name))
             (probe-file (merge-pathnames #p"metadata" file))
             (let (*db*)
               (handler-case (open-triple-store file)
                 (error (e) (request-failed* *response-internal-server-error* (princ-to-string e))))
               (set-store-open catalog *db* name))))))

(defun create-store (catalog name)
  (let (*db*)
    (handler-case (create-triple-store (store-file name catalog))
      (error (e) (request-failed* *response-internal-server-error* (princ-to-string e))))
    (set-store-open catalog *db* name)))

(defun delete-store (catalog store)
  (close-triple-store :db (@db store))
  (delete-directory-and-files (store-file (@name store) catalog))
  (remhash (@name store) (@open-stores catalog)))

(defparameter *default-namespaces*
  '(("rdf" "http://www.w3.org/1999/02/22-rdf-syntax-ns#")
    ("rdfs" "http://www.w3.org/2000/01/rdf-schema#")
    ("owl" "http://www.w3.org/2002/07/owl#")
    ("dc" "http://purl.org/dc/elements/1.1/")
    ("dcterms" "http://purl.org/dc/terms/")
    ("foaf" "http://xmlns.com/foaf/0.1/")
    ("fti" "http://franz.com/ns/allegrograph/2.2/textindex/")
    ("skos" "http://www.w3.org/2004/02/skos/core#")))

(defclass environment ()
  ((id :initarg :id :reader @id :index :any-unique)
   (namespaces :initform *default-namespaces* :accessor @namespaces)
   (functors :initform nil :accessor @functors)
   (prolog-package :reader @prolog-package :allocation :instance))
  (:metaclass persistent-class))

(defmethod @prolog-package :before ((environment environment))
  (unless (slot-boundp environment 'prolog-package)
    (setf (slot-value environment 'prolog-package)
          (make-prolog-package (@functors environment) (@namespaces environment)))))

(defun get-environment (catalog store name)
  (or (with-catalog-cache (catalog)
        (retrieve-from-index 'environment 'id (if name (list store name) store)))
      (and (not name)
           (with-catalog-cache (catalog t)
             (make-instance 'environment :id store)))))

(defun list-environments (catalog store)
  (let ((names ()))
    (with-catalog-cache (catalog)
      (doclass (env 'environment)
        (when (and (consp (@id env)) (string= (first (@id env)) store))
          (push (second (@id env)) names))))
    (nreverse names)))

(defclass agraph-http-server ()
  ((wserver :initarg :wserver :reader @wserver)
   (catalogs :initform nil :accessor @catalogs)))

(defun catalog-urls (server)
  (mapcar #'car (@catalogs server)))

(defun create-server (&key (port 80) (catalog-url "/catalogs") wserver-args)
  (let* ((*wserver* (make-instance 'wserver))
         (server (make-instance 'agraph-http-server :wserver *wserver*)))
    (apply #'start :port port wserver-args)
    (when catalog-url
      (publish-catalog-list catalog-url *wserver* server))
    server))

(defun shutdown-server (server)
  (loop :for (nil . catalog) :in (@catalogs server)
        :do (close-catalog catalog))
  (shutdown :server (@wserver server)))

(defun add-catalog (server directory &key prefix username password)
  (setf directory (directorify-path directory))
  (if prefix
      (when (assoc prefix (@catalogs server) :test #'string=)
        (error "There is already a catalog published at '~a'" prefix))
      (flet ((make-prefix (name num)
               (format nil "/catalogs/~a~a/" (net.aserve::encode-form-urlencoded name :external-format *utf8*)
                       (if (zerop num) "" num))))
        (let ((name (or (directory-name directory) "x")))
          (loop :for num :from 0
                :for pr := (make-prefix name num)
                :do (unless (assoc pr (@catalogs server) :test #'string=)
                      (setf prefix pr)
                      (return))))))
  (let ((catalog (make-instance 'catalog :directory directory :username username :password password)))
    (push (cons prefix catalog) (@catalogs server))
    (publish-catalog (@wserver server) catalog :prefix prefix))
  (values))
