;; TODO user accounts

(in-package :agraph-http-server)

(defclass agraph-http-server ()
  ((cache :reader @cache)
   (lock :initform (mp:make-process-lock) :reader @lock)
   (directory :initarg :directory :reader @directory)
   (open-stores :initform (make-hash-table :test 'equal) :reader @open-stores)
   (open-environments :initform (make-hash-table :test 'equal) :reader @open-environments)
   (username :initform nil :initarg :username :reader @username)
   (password :initform nil :initarg :password :reader @password)))

(defmacro with-server-cache ((server &optional write-p) &body body)
  `(flet ((body () ,@body))
     (let* ((server ,server)
            (*allegrocache* (@cache server)))
       (mp:with-process-lock ((@lock server))
         (rollback)
         ,(if write-p '(prog1 (body) (commit)) '(body))))))

(defmethod initialize-instance :after ((server agraph-http-server) &key cache-file &allow-other-keys)
  (let ((dir (namestring (@directory server))))
    (assert dir)
    (unless (char= #\/ (char dir (1- (length dir))))
      (setf dir (concatenate 'string dir "/")
            (slot-value server 'directory) dir))
    (unless (probe-file dir)
      (make-directory dir))
    (setf (slot-value server 'cache)
          (let (*allegrocache*) (open-file-database (or cache-file (namestring (merge-pathnames "_serverdata" dir)))
                                                    :if-does-not-exist :create)))))

(defun close-http-server (server)
  (close-database :db (@cache server))
  (maphash (lambda (name db)
             (declare (ignore name))
             (close-triple-store db))
           (@open-stores server)))

(defclass open-store ()
  ((db :initarg :db :reader @db)
   (name :initarg :name :reader @name)
   (reasoning-db :initarg :reasoning-db :reader @reasoning-db)))

(defun store-file (name server)
  (merge-pathnames (format nil "~a/" name) (@directory server)))  

(defun set-store-open (server db name)
  (setf (gethash name (@open-stores server))
        (make-instance 'open-store :db db :name name
                       :reasoning-db (db-apply-reasoner db 'rdfs++-reasoner name))))

(defun list-stores (server)
  (loop :for sub :in (directory (@directory server) :directories-are-files nil)
        :when (and (not (pathname-name sub)) (probe-file (merge-pathnames #p"metadata" sub)))
        :collect (car (last (pathname-directory sub)))))

(defun get-store (server name)
  (or (gethash name (@open-stores server))
      (let ((file (store-file name server)))
        (and (probe-file (merge-pathnames #p"metadata" file))
             (let (*db*)
               (handler-case (open-triple-store file)
                 (error (e) (request-failed* *response-internal-server-error* (princ-to-string e))))
               (set-store-open server *db* name))))))

(defun create-store (server name)
  (let (*db*)
    (handler-case (create-triple-store (store-file name server))
      (error (e) (request-failed* *response-internal-server-error* (princ-to-string e))))
    (set-store-open server *db* name)))

(defun delete-store (server store)
  (close-triple-store :db (@db store))
  (delete-directory-and-files (store-file (@name store) server))
  (remhash (@name store) (@open-stores server)))

(defparameter *default-namespaces*
  '(("rdf" "http://www.w3.org/1999/02/22-rdf-syntax-ns#")
    ("rdfs" "http://www.w3.org/2000/01/rdf-schema#")
    ("owl" "http://www.w3.org/2002/07/owl#")
    ("dc" "http://purl.org/dc/elements/1.1/")
    ("dcterms" "http://purl.org/dc/terms/")
    ("foaf" "http://xmlns.com/foaf/0.1/")
    ("fti" "http://franz.com/ns/allegrograph/2.2/textindex/")
    ("skos" "http://www.w3.org/2004/02/skos/core#")))

(defclass environment ()
  ((id :initarg :id :reader @id :index :any-unique)
   (namespaces :initform *default-namespaces* :accessor @namespaces)
   (functors :initform nil :accessor @functors)
   (prolog-package :reader @prolog-package :allocation :instance))
  (:metaclass persistent-class))

(defmethod @prolog-package :before ((environment environment))
  (unless (slot-boundp environment 'prolog-package)
    (setf (slot-value environment 'prolog-package)
          (make-prolog-package (@functors environment) (@namespaces environment)))))

(defun get-environment (server store name)
  (or (with-server-cache (server)
        (retrieve-from-index 'environment 'id (if name (list store name) store)))
      (and (not name)
           (with-server-cache (server t)
             (make-instance 'environment :id store)))))

(defun list-environments (server store)
  (let ((names ()))
    (with-server-cache (server)
      (doclass (env 'environment)
        (when (and (consp (@id env)) (string= (first (@id env)) store))
          (push (second (@id env)) names))))
    (nreverse names)))
