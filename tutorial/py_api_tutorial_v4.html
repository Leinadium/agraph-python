<html>
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Python API for AllegroGraph</title>

<style type="text/css">

pre.code { margin-left:4em; }
code.code { background-color:#ADDFFF; }

</style>
</head>
<body>
<h1>Python API for AllegroGraph</h1>
<p>
The Python API for the AllegroGraph system is a client-side API that implements convenient and efficient
access to an AllegroGraph server from a Python-based application.  This API consciously imitates the
structure and functionality of the (Java-based) Sesame Repository API.  It offers methods for
querying and updating RDF data. Here we provide examples that illustrate how to program
against the Python API.  Developers who are already familiar
with Sesame will find it especially easy to use the Python API.  
	</p><p>

<h2>Creating a Repository object</h2>

The 'Repository' class enables an application to
establish a connection with an AllegroGraph server. 
The first step in any application is to create an AllegroGraphStore object, and then
to pass that object as the parameter to creation of a Repository object.
The code below illustrates how this is done.  The arguments to 'AllegroGraphStore'
specify (1) how the store should be created/opened (in this case, an open that
clears any previous quads in the store) (2) the host machine on which the server is running,
(3) the name of the store, (4) the location of a local directory where persistent files are maintained,
(5) an optional port number.  Once a repository object is created and initialized, it is ready
to process commands.

</p>
<pre class="code" ><code class="code">
from franz.openrdf.repository.repository import Repository
from franz.openrdf.sail.allegrographstore import AllegroGraphStore

sesameDir = "/Users/bmacgregor/Desktop/SesameFolder"
store = AllegroGraphStore(AllegroGraphStore.RENEW, "localhost", "testP",
                          sesameDir, port=4567)
myRepository = Repository(store)
myRepository.initialize()
</code></pre>

<h2>Asserting and Retracting Triples</h2>
<p>

Resource and literal objects are created by an instance of 'ValueFactory', which itself is
created by calling the method 'Repository.getValueFactory'.  Below, we show how
to create resources describing two
people, named 'Bob' and 'Alice'.  Assertions and retractions to the quad store
are executed by 'add' and 'remove' methods belonging to a Connection class.
A connection is created by calling the method 'Repository.getConnection()'.
A number of classes and properties for the RDF, RDFS, XSD, and OWL ontologies
are predefined.  'RDF.TYPE' is one such.

</p><p>
The 'add' and 'remove' methods take an optional 'contexts' argument that
specifies one or more contexts that are the the target of triple assertions
and retractions.  When the context is omitted, triples are asserted/retracted
to/from the null context.  In the example below, facts about Alice and Bob
reside in the null context.

</p><pre class="code" ><code class="code">
f = myRepository.getValueFactory()
## create some resources and literals to make statements out of
alice = f.createURI("http://example.org/people/alice")
bob = f.createURI("http://example.org/people/bob")
name = f.createURI("http://example.org/ontology/name")
person = f.createURI("http://example.org/ontology/Person")
bobsName = f.createLiteral("Bob")
alicesName = f.createLiteral("Alice")

conn = myRepository.getConnection()
## alice is a person
conn.add(alice, RDF.TYPE, person)
## alice's name is "Alice"
conn.add(alice, name, alicesName)
## bob is a person
conn.add(bob, RDF.TYPE, person)
## bob's name is "Bob":
conn.add(bob, name, bobsName)
print "Triple count: ", conn.size()
conn.remove(bob, name, bobsName)
print "Triple count: ", conn.size()
conn.add(bob, name, bobsName)
</code></pre>

<h2>A SPARQL Query</h2>
<p>

Our next example illustrates how to evaluate a SPARQL query, in this case, one
that retrieves all triples in a store.  The method 'Connection.prepareTupleQuery'
creates a query object that can be evaluated one or more times.  Currently,
the only query language supported is SPARQL.  The results of evaluating a
query are returned in an iterator that yields a sequence of BindingSets.
Below we illustrate one (rather heavyweight) method for extracting the values
from a binding set, indexed by the name of the corresponding column variable
in the SELECT clause.
</p><p>

The Connection class is designed to be created for the duration of a sequence
of updates and queries, and then closed.  In practice, many AllegroGraph applications
keep a connection open indefinitely.  However, best practice dictates that
the connection is closed, as illustrated below.  The same hygiene applies to
the iterators that generate binding sets.

</p><pre class="code" ><code class="code">
try:
    queryString = "SELECT ?s ?p ?o WHERE {?s ?p ?o .}"
    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)
    result = tupleQuery.evaluate();
    try:
        for bindingSet in result:
            s = bindingSet.getValue("s")
            p = bindingSet.getValue("p")
            o = bindingSet.getValue("o")          
            print "%s %s %s" % (s, p, o)
    finally:
        result.close();
finally:
    conn.close();
</code></pre>

<h2>Statement Matching</h2>
<p>
The method 'Connection.getStatements' provides a streamlined alternative to 
SPARQL queries when the patterns to be matched are very simple.  In a Sesame
implementation where the repository and server are running in the same Java
thread, a 'getStatements' call is much more efficient than a SPARQL query.
However, AllegroGraph is currently accessible from Python only in a client/server
configuration, and in that configuration, the processing times are comparable.
Hence, 'getStatements' represents sugar-coating.

</p><p>
Below, we illustrate two kinds of 'getStatement' calls.  The first mimics
traditional Sesame syntax, and returns a Statement object at each iteration.
Most of the time, this is a waste, since applications rarely make use of Statement
objects.
The second syntax borrows a trick from the JDBC API commonly used to access relational
databases.  A result set iterator does not materialize objects unless forced
to.  Here, it materializes only values of the object-position of the returned
triples.  The 'getValue' call forces materialization of a resource or literal, while
the 'getString' call returns a string without creating an object.  Developers
who care about minimizing garbage will prefer to use the 'getJDBCStatements' call,
and they will usually call 'getString' in preference to 'getValue'.
</p>
<pre class="code"><code class="code">
conn = myRepository.getConnection()
alice = myRepository.getValueFactory().createURI("http://example.org/people/alice")
statements = conn.getStatements(alice, None, None, False, [])
for s in statements:
    print s
    print "Same thing using JDBC:"
    resultSet = conn.getJDBCStatements(alice, None, None, False, [])
while resultSet.next():
    print "   ", resultSet.getValue(3), "   ", resultSet.getString(3)  
</code></pre>
<p>
The last argument to 'getStatements' takes a context or a list of contexts.  If that list
is instantiated, then only triples belonging to the enumerated contexts are
retrieved.  A value of 'None' denotes matching against the null context.  Above,
we are retrieving from all contexts.

<!-- TODO: TEST OUT  ", None)" VS. ", [None])" MATCHING. -->
</p>
The next example illustrates some variations on what we have seen so far.  First,
observe that 'ValueFactory.createURI' can be called with one or two arguments; when
called with two, the namespace and local name are specified separately, and
combined by the system.  This is recommended, since it eliminates the need to replicate
the same namespace over and over.  Next, we show examples of various ways to declare
typed literals, and language-specific literals.
</p><p>
In the Sesame API, the 'Connection.add' method is overloaded, enabling it to
be called to add triples/quads, to add statement objects, and to load a file.  We
emulate that overloading in our Python implementation, but in fact static overloading
does not usually mesh well with optional arguments, which are preferred in Python.
Hence, we recommend calling 'addStatement' in preference to 'add' when adding
a statement object, and calling 'addFile' in preference to 'add' when loading
an RDF file into the quad store.  Below, we show examples of both types of calls
side-by-side.
</p><p>
The RDF/SPARQL spec is conservative to a fault when defining matching between
various combinations of literal values.  The match and query statements below
illustrate how some of these combinations perform.  Note that we illustrate an
alternate syntax for pulling values out of a BindingSet object which takes
advantage of the fact that our BindingSet can emulate a Python 'dict'.
</p>
<pre class="code"><code class="code">
conn.clear()
exns = "http://example.org/people/"
alice = f.createURI("http://example.org/people/alice")
age = f.createURI(namespace=exns, localname="age")
weight = f.createURI(namespace=exns, localname="weight")
favoriteColor = f.createURI(namespace=exns, localname="favoriteColor")
birthdate = f.createURI(namespace=exns, localname="birthdate")
ted = f.createURI(namespace=exns, localname="Ted")
red = f.createLiteral('Red')
rouge = f.createLiteral('Rouge', language="fr")
fortyTwo = f.createLiteral('42', datatype=XMLSchema.INT)
fortyTwoInteger = f.createLiteral('42', datatype=XMLSchema.LONG)
fortyTwoUntyped = f.createLiteral('42')
date = f.createLiteral('1984-12-06', datatype=XMLSchema.DATE) 
time = f.createLiteral('1984-12-06', datatype=XMLSchema.DATETIME) 
stmt1 = f.createStatement(alice, age, fortyTwo)
stmt2 = f.createStatement(ted, age, fortyTwoUntyped)
conn.add(stmt1)
conn.addStatement(stmt2)
conn.addTriple(alice, weight, f.createLiteral('20.5'))
conn.addTriple(ted, weight, f.createLiteral('20.5', datatype=XMLSchema.FLOAT))
conn.add(alice, favoriteColor, red)
conn.add(ted, favoriteColor, rouge)
conn.add(alice, birthdate, date)
conn.add(ted, birthdate, time)
for obj in [None, fortyTwo, fortyTwoUntyped, f.createLiteral('20.5', datatype=XMLSchema.FLOAT), f.createLiteral('20.5'),
            red, rouge]:
    print "Retrieve triples matching '%s'." % obj
    statements = conn.getStatements(None, None, obj, False, None)
    for s in statements:
        print s
for obj in ['42', '"42"', '20.5', '"20.5"', '"20.5"^^xsd:float', '"Rouge"@fr', '"1984-12-06"^^xsd:date']:
    print "Query triples matching '%s'." % obj
    queryString = """PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
    SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = %s)}
    """ % obj
    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)
    result = tupleQuery.evaluate();
        for bindingSet in result:
        s = bindingSet[0]
        p = bindingSet[1]
        o = bindingSet[2]
        print "%s %s %s" % (s, p, o)
fortyTwoInt = f.createLiteral(42)
print fortyTwoInt.toPython()
</code></pre>
<p>

<h2>Importing and Exporting Triples</h2>
<p>
The Python API client can load either RDF/XML files or NTriples files into
a quad store.  The example below calls 'Connection.add' to load from
an NTriples file and 'Connection.addFile' to load from an RDF/XML file
(both methods work; the latter is recommended).   NTriples and RDF/XML files can
only store triples.  In the case of the 'add' call, we have omitted the context
argument, so by default, the triples are loaded into the null context.  The
'addFile' call includes an explicit context setting, so the fourth argument of
each vcard triple will be the context named "/tutorial/vc_db_1_rdf".
The 'Connection.size' method takes an optional context argument.  With no
argument, it returns the total number of quads.  Below, it returns the number
'16' for the 'context' context argument, and the number '28' for the null context
(None) argument.
</p>
<pre class="code"><code class="code">
conn.clear()   
path1 = "./vc-db-1.rdf"    
path2 = "./football.nt"            
baseURI = "http://example.org/example/local"
location = "/tutorial/vc_db_1_rdf" 
context = myRepository.getValueFactory().createURI(location)
conn.setNamespace("vcd", "http://www.w3.org/2001/vcard-rdf/3.0#");
## read football triples into the null context:
conn.add(path2, base=baseURI, format=RDFFormat.NTRIPLES)
## read vcards triples into the context 'context':
conn.addFile(path1, baseURI, format=RDFFormat.RDFXML, context=context);
myRepository.indexTriples(all=True)
print "After loading, repository contains %s vcard triples and %s football triples." % (conn.size(context), conn.size(None))
</code></pre>
<p>
The SPARQL query below binds a context variable '?c' to the context associated with
each triple.  It prints out the each URI that appears in subject position, together with
the name of the corresponding context.  The null context returns 'None'.
</p>
<pre class="code"><code class="code">
conn = test6().getConnection()
queryString = "SELECT DISTINCT ?s ?c WHERE {graph ?c {?s ?p ?o .} }"
tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)
result = tupleQuery.evaluate();
for bindingSet in result:
    print bindingSet[0], bindingSet[1]
</code></pre>
<p>

</p>
<h2>XXX</h2>
<p>
</p>
<pre class="code"><code class="code">

</code></pre>
<p>

</p>


</p>
<h2>XXX</h2>
<p>
</p>
<pre class="code"><code class="code">

</code></pre>
<p>

</p>

</body>
