<html>
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Python API for AllegroGraph</title>

<style type="text/css">

pre.code { margin-left:2em; }

</style>
</head>
<body>
<h1>Python API for AllegroGraph</h1>
<p>
The Python API for the AllegroGraph system is a client-side API that implements convenient and efficient
access to an AllegroGraph server from a Python-based application.  This API consciously imitates the
structure and functionality of the (Java-based) Sesame Repository API.  It offers methods for
querying and updating RDF data. Here we provide examples that illustrate how to program
against the Python API.  Developers who are already familiar
with Sesame will find it especially easy to use the Python API.  
	</p><p>

<h2>Creating a Repository object</h2>

The 'Repository' class enables an application to
establish a connection with an AllegroGraph server. 
The first step in any application is to create an AllegroGraphStore object, and then
to pass that object as the parameter to creation of a Repository object.
The code below illustrates how this is done.  The arguments to 'AllegroGraphStore'
specify (1) how the store should be created/opened (in this case, an open that
clears any previous quads in the store) (2) the host machine on which the server is running,
(3) the name of the store, (4) the location of a local directory where persistent files are maintained,
(5) an optional port number.  Once a repository object is created and initialized, it is ready
to process commands.

</p>
<pre class="code" >
    from franz.openrdf.repository.repository import Repository
    from franz.openrdf.sail.allegrographstore import AllegroGraphStore

    sesameDir = "/Users/bmacgregor/Desktop/SesameFolder"
    store = AllegroGraphStore(AllegroGraphStore.RENEW, "localhost", "testP",
                              sesameDir, port=4567)
    myRepository = Repository(store)
    myRepository.initialize()
</pre>

<h2>Asserting and Retracting Triples</h2>
<p>

Resource and literal objects are created by an instance of 'ValueFactory', which itself is
created by calling the method 'Repository.getValueFactory'.  Below, we show how
to create resources describing two
people, named 'Bob' and 'Alice'.  Assertions and retractions to the quad store
are executed by 'add' and 'remove' methods belonging to a Connection class.
A connection is created by calling the method 'Repository.getConnection()'.
A number of classes and properties for the RDF, RDFS, XSD, and OWL ontologies
are predefined.  'RDF.TYPE' is one such.

</p><p>
The 'add' and 'remove' methods take an optional 'contexts' argument that
specifies one or more contexts that are the the target of triple assertions
and retractions.  When the context is omitted, triples are asserted/retracted
to/from the null context.  In the example below, facts about Alice and Bob
reside in the null context.

</p><pre class="code" >
    f = myRepository.getValueFactory()
    ## create some resources and literals to make statements out of
    alice = f.createURI("http://example.org/people/alice")
    bob = f.createURI("http://example.org/people/bob")
    name = f.createURI("http://example.org/ontology/name")
    person = f.createURI("http://example.org/ontology/Person")
    bobsName = f.createLiteral("Bob")
    alicesName = f.createLiteral("Alice")

    conn = myRepository.getConnection()
    ## alice is a person
    conn.add(alice, RDF.TYPE, person)
    ## alice's name is "Alice"
    conn.add(alice, name, alicesName)
    ## bob is a person
    conn.add(bob, RDF.TYPE, person)
    ## bob's name is "Bob":
    conn.add(bob, name, bobsName)
    print "Triple count: ", conn.size()
    conn.remove(bob, name, bobsName)
    print "Triple count: ", conn.size()
    conn.add(bob, name, bobsName)
</pre>

<h2>A SPARQL Query</h2>
<p>

Our next example illustrates how to evaluate a SPARQL query, in this case, one
that retrieves all triples in a store.  The method 'Connection.prepareTupleQuery'
creates a query object that can be evaluated one or more times.  Currently,
the only query language supported is SPARQL.  The results of evaluating a
query are returned in an iterator that yields a sequence of BindingSets.
Below we illustrate one (rather heavyweight) method for extracting the values
from a binding set, indexed by the name of the corresponding column variable
in the SELECT clause.
</p><p>

The Connection class is designed to be created for the duration of a sequence
of updates and queries, and then closed.  In practice, many AllegroGraph applications
keep a connection open indefinitely.  However, best practice dictates that
the connection is closed, as illustrated below.  The same hygiene applies to
the iterators that generate binding sets.

</p><pre class="code" >
    try:
        queryString = "SELECT ?s ?p ?o WHERE {?s ?p ?o .}"
        tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)
        result = tupleQuery.evaluate();
        try:
            for bindingSet in result:
                s = bindingSet.getValue("s")
                p = bindingSet.getValue("p")
                o = bindingSet.getValue("o")              
                print "%s %s %s" % (s, p, o)
        finally:
            result.close();
    finally:
        conn.close();
</pre>

<h2>Statement Matching</h2>
<p>
The method 'Connection.getStatements' provides a streamlined alternative to 
SPARQL queries when the patterns to be matched are very simple.  In a Sesame
implementation where the repository and server are running in the same Java
thread, a 'getStatements' call is much more efficient than a SPARQL query.
However, AllegroGraph is currently accessible from Python only in a client/server
configuration, and in that configuration, the processing times are comparable.
Hence, 'getStatements' represents sugar-coating.

</p><p>
Below, we illustrate two kinds of 'getStatement' calls.  The first mimics
traditional Sesame syntax, and returns a Statement object at each iteration.
Most of the time, this is a waste, since applications rarely make use of Statement
objects.
The second syntax borrows a trick from the JDBC API commonly used to access relational
databases.  A result set iterator does not materialize objects unless forced
to.  Here, it materializes only values of the object-position of the returned
triples.  The 'getValue' call forces materialization of a resource or literal, while
the 'getString' call returns a string without creating an object.  Developers
who care about minimizing garbage will prefer to use the 'getJDBCStatements' call,
and they will usually call 'getString' in preference to 'getValue'.
</p>
<pre class="code">
    conn = myRepository.getConnection()
    alice = myRepository.getValueFactory().createURI("http://example.org/people/alice")
    statements = conn.getStatements(alice, None, None, False, [])
    for s in statements:
        print s
    print "Same thing using JDBC:"
    resultSet = conn.getJDBCStatements(alice, None, None, False, [])
    while resultSet.next():
        print "   ", resultSet.getValue(3), "   ", resultSet.getString(3)  
</pre>
<p>
The last argument to 'getStatements' takes a context or a list of contexts.  If that list
is instantiated, then only triples belonging to the enumerated contexts are
retrieved.  A value of 'None' denotes matching against the null context.  Above,
we are retrieving from all contexts.

<!-- TODO: TEST OUT  ", None)" VS. ", [None])" MATCHING. -->
</p>
The next example illustrates some variations on what we have seen so far.  First,
observe that 'ValueFactory.createURI' can be called with one or two arguments; when
called with two, the namespace and local name are specified separately, and
combined by the system.  This is recommended, since it eliminates the need to replicate
the same namespace over and over.  Next, we show examples of various ways to declare
typed literals, and language-specific literals.
</p><p>
In the Sesame API, the 'Connection.add' method is overloaded, enabling it to
be called to add triples/quads, to add statement objects, and to load a file.  We
emulate that overloading in our Python implementation, but in fact static overloading
does not usually mesh well with optional arguments, which are preferred in Python.
Hence, we recommend calling 'addStatement' in preference to 'add' when adding
a statement object, and calling 'addFile' in preference to 'add' when loading
an RDF file into the quad store.  Below, we show examples of both types of calls
side-by-side.
</p><p>
The RDF/SPARQL spec is conservative to a fault when defining matching between
various combinations of literal values.  The match and query statements below
illustrate how some of these combinations perform.  Note that we illustrate an
alternate syntax for pulling values out of a BindingSet object which takes
advantage of the fact that our BindingSet can emulate a Python 'dict'.
</p>
<pre class="code">
    conn.clear()
    exns = "http://example.org/people/"
    alice = f.createURI("http://example.org/people/alice")
    age = f.createURI(namespace=exns, localname="age")
    weight = f.createURI(namespace=exns, localname="weight")    
    favoriteColor = f.createURI(namespace=exns, localname="favoriteColor")
    birthdate = f.createURI(namespace=exns, localname="birthdate")
    ted = f.createURI(namespace=exns, localname="Ted")
    red = f.createLiteral('Red')
    rouge = f.createLiteral('Rouge', language="fr")
    fortyTwo = f.createLiteral('42', datatype=XMLSchema.INT)
    fortyTwoInteger = f.createLiteral('42', datatype=XMLSchema.LONG)    
    fortyTwoUntyped = f.createLiteral('42')
    date = f.createLiteral('1984-12-06', datatype=XMLSchema.DATE)     
    time = f.createLiteral('1984-12-06', datatype=XMLSchema.DATETIME)         
    stmt1 = f.createStatement(alice, age, fortyTwo)
    stmt2 = f.createStatement(ted, age, fortyTwoUntyped)    
    conn.add(stmt1)
    conn.addStatement(stmt2)
    conn.addTriple(alice, weight, f.createLiteral('20.5'))
    conn.addTriple(ted, weight, f.createLiteral('20.5', datatype=XMLSchema.FLOAT))
    conn.add(alice, favoriteColor, red)
    conn.add(ted, favoriteColor, rouge)
    conn.add(alice, birthdate, date)
    conn.add(ted, birthdate, time)    
    for obj in [None, fortyTwo, fortyTwoUntyped, f.createLiteral('20.5', datatype=XMLSchema.FLOAT), f.createLiteral('20.5'),
                red, rouge]:
        print "Retrieve triples matching '%s'." % obj
        statements = conn.getStatements(None, None, obj, False, None)
        for s in statements:
            print s
    for obj in ['42', '"42"', '20.5', '"20.5"', '"20.5"^^xsd:float', '"Rouge"@fr', '"1984-12-06"^^xsd:date']:
        print "Query triples matching '%s'." % obj
        queryString = """PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
        SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = %s)}
        """ % obj
        tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)
        result = tupleQuery.evaluate();    
        for bindingSet in result:
            s = bindingSet[0]
            p = bindingSet[1]
            o = bindingSet[2]
            print "%s %s %s" % (s, p, o)
    fortyTwoInt = f.createLiteral(42)
    print fortyTwoInt.toPython()
</pre>
<p>

<h2>Importing and Exporting Triples</h2>
<p>
The Python API client can load either RDF/XML files or NTriples files into
a quad store.  The first example below calls 'Connection.add' to load from
an RDF/XML file.  RDF/XML files can only store triples, so a context
argument must be appended to indicate what context the triples should be added
to.  In this example, the context has been omitted, indicating that they should
be added to the null context.
</p>
<pre class="code">
    file = open("./vc-db-1.rdf")            
    baseURI = "http://example.org/example/local"
    try:
        conn = myRepository.getConnection();
        conn.clear() ## retract any existing triples
        conn.add(file, base=baseURI, format=RDFFormat.RDFXML)
        print "After loading, repository contains %s triples." % conn.size(None)
        try:
            resultSet = conn.getJDBCStatements(None, None, None, False, [])
            while resultSet.next():
                print resultSet.getString(1), resultSet.getString(2), resultSet.getString(3)
        finally:
            resultSet.close()
    finally:
        conn.close()
</pre>
<p>
In this next example, we call 'Connection.addFile' to load from an NTriples file into
a context other than the null context.
</p>
<pre class="code">
    path = "./football.nt"            
    baseURI = "http://example.org/example/local"
    try:
        conn = myRepository.getConnection();
        conn.clear() ## retract any existing triples
        conn.addFile(path, base=baseURI, format=RDFFormat.NTRIPLES) 
        print "After loading, repository contains %s triples." % conn.size(None)
        for s in conn.getStatements(None, None, None, False, []):
            print s
    finally:
        conn.close()
</pre>
<p>

</p>
<h2>XXX</h2>
<p>
</p>
<pre class="code">

</pre>
<p>

</p>


</p>
<h2>XXX</h2>
<p>
</p>
<pre class="code">

</pre>
<p>

</p>

</body>
