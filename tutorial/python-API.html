<html>
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Python API Tutorial for AllegroGraph 3.2</title>

<style type="text/css">

.input { margin-left:4em; background-color:#ADDFFF;}
.output { margin-left:4em; background-color:#F1F1F1;}
.returnlink {font-size:small;  font-weight:normal; }

</style>
</head>
<body>
<h1>Python API Reference for AllegroGraph 3.2</h1>
<p>This is a description of the Python Application Programmer's Interface (API) to AllegroGraph RDFStore&#8482; version 3.2 from <a href="http://agraph.franz.com/allegrograph/">Franz Inc.</a> </p>
<p>
The Python API offers convenient and efficient
access to an AllegroGraph server from a Python-based application.  This API provides methods for
creating, querying and maintaining RDF data, and for managing the stored triples. </p>
<table border="1">
    <tr>
        <td width="867">The Python API deliberately emulates the Aduma Sesame API to make it easier to migrate from Sesame to AllegroGraph.&nbsp; The Python API has also been extended in ways that make it easier and more intuitive than the Sesame API.</td>
    </tr>
</table>
<h2 id="Contents">Contents</h2>
<ul>
  <li><a href="#AllegroGraphServer Class">AllegroGraphServer Class</a></li>
  <li><a href="#Catalog Class">Catalog Class</a></li>
  <li><a href="#Repository Class">Repository Class</a></li>
  <li><a href="#RepositoryConnection Class">RepositoryConnection Class</a></li>
  <li><a href="#Query Class">Query Class</a></li>
  <ul>
  <li><a href="#Subclass TupleQuery">Subclass TupleQuery</a></li>
  <li><a href="#Subclass GraphQuery">Subclass GraphQuery</a></li>
  <li><a href="#Subclass BooleanQuery">Subclass BooleanQuery</a></li>
  </ul>
  <li><a href="#RepositoryResult Class">RepositoryResult Class</a> </li>
  <li><a href="#Statement Class">Statement Class</a>  </li>
  <li><a href="#ValueFactory Class">ValueFactory Class</a></li>
</ul>
<h2 id="AllegroGraphServer Class">AllegroGraphServer Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The AllegroGraphServer  object represents a remote AllegroGraph server on the network.&nbsp; It is used to inventory and access the catalogs of that server.</p>
<p> Source: \AllegroGraphDirectory\python\franz\openrdf\sail\allegrographserver.py.</p>
<h3>Constructor</h3>
<p>AllegroGraphServer(self, host, port=4567)</p>
<ul>
  <li><em>host</em> is a string describing the network path to the AllegroGraph server. No default. </li>
  <li><em>port</em> is a string containing the AllegroGraph HTTP port on the server. It defaults to &quot;4567&quot;. </li>
</ul>
<dl>
  <dt>Example:</dt>
</dl>
<pre>    server = AllegroGraphServer(path=&quot;localhost&quot;, port=&quot;8080&quot;) </pre>
<h3>Methods</h3>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;"  >
  <tr>
      <td width="125">getHost(self)</td>
      <td width="634">Returns a string containing the path to the host server. </td>
  </tr>
  <tr>
      <td>listCatalogs(self)</td>
      <td>Returns a string containing the names of the server's catalogs. </td>
  </tr>
  <tr>
      <td>openCatalog(self, shortName)</td>
      <td>Returns a <a href="#Catalog Class">Catalog</a> object. <em>shortName</em> is one of the catalog names from listCatalogs(). </td>
  </tr>

</table>
<h2 id="Catalog Class">Catalog Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>A Catalog object is a container for multiple repositories.&nbsp; </p>
<p>Source: \AllegroGraphDirectory\python\franz\openrdf\sail\allegrographserver.py.</p>
<h3>Constructor</h3>
<p>Catalog(self, short_name, mini_catalog, server) </p>
<ul>
  <li><em>short_name</em> is the name of the catalog from <a href="#AllegroGraphServer Class">AllegroGraphServer</a>.listCatalogs(). </li>
  <li><em>mini_catalog</em> is an internal data structure supplied by the <a href="#AllegroGraphServer Class">AllegroGraphServer</a>.openCatalog() method. </li>
  <li><em>server</em> is the <a href="#AllegroGraphServer Class">AllegroGraphServer</a> object that called this constructor. </li>
</ul>
<p>Example:&nbsp; Best practice is to invoke the Catalog constructor using <a href="#AllegroGraphServer Class">AllegroGraphServer</a>.openCatalog(), which supplies the specialized arguments needed by the Catalog contructor.</p>
<pre>    catalog = server.openCatalog('scratch') </pre>
<h3>Methods</h3>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
      <td valign="top">close(self)</td>
      <td>Closes the Catalog.&nbsp; It is a &quot;best practice&quot; to close Catalogs when you are finished with them.</td>
  </tr>
  <tr>
      <td width="168" valign="top">getName(self)</td>
      <td width="591">Returns a string containing the name of this Catalog. </td>
  </tr>
  <tr>
      <td valign="top">getRepository(self, name, access_verb)</td>
      <td>Returns a <a href="#Repository Class">Repository</a> object.&nbsp; <em>name </em>is a repository name from listRepositories(). <em>access_verb</em> is one of the following:
              <ul>
                  <li><strong>Repository.RENEW</strong> clears the contents of an existing repository before opening. If the indicated repository does not exist, it creates one. </li>
                  <li><strong>Repository.OPEN</strong> opens an existing repository, or throws an exception if the repository is not found. </li>
                  <li><strong>Repository.ACCESS</strong> opens an existing repository, or creates a new one if the repository is not found.</li>
                  <li><strong>Repository.CREATE</strong> creates a new repository, or throws an exception if one by that name already exists.</li>
          </ul></td>
  </tr>
  <tr>
      <td valign="top">listRepositories(self)</td>
      <td>Returns a list of repository names (triple stores) managed by this Catalog.</td>
  </tr>
</table>
<h2 id="Repository Class">Repository Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>A repository contains RDF data that can be queried and updated.
Access to the repository can be acquired by openening a connection to it.
This connection can then be used to query and/or update the contents of the
repository. Depending on the implementation of the repository, it may or may
not support multiple concurrent connections.</p>
<p>Please note that a repository needs to be initialized before it can be used
and that it should be shut down before it is discarded/garbage collected.
Forgetting the latter can result in loss of data (depending on the Repository
implementation)! </p>
<p>Source: \AllegroGraphDirectory\python\franz\openrdf\repository\repository.py.</p>
<h3>Constructor</h3>
<p>Repository(self, catalog, database_name, access_verb)</p>
<ul>
  <li><em>catalog</em> is the <a href="#Catalog Class">Catalog</a> object that created this Repository using <a href="#Catalog Class">Catalog</a>.getRepository(). </li>
  <li><em>repository_name</em> is the name of a repository from <a href="#Catalog Class">Catalog</a>.listRepositories(). </li>
  <li><em>access_verb</em> is one of the following: </li>
<ul>
  <li><strong>Repository.RENEW</strong> clears the contents of an existing repository before opening. If the indicated repository does not exist, 
  it creates one. </li>
  <li><strong>Repository.OPEN</strong> opens an existing repository, or throws an exception if the repository is not found. </li>
  <li><strong>Repository.ACCESS</strong> opens an existing repository, or creates a new one if the repository is not found.</li>
  <li><strong>Repository.CREATE</strong> creates a new repository, or throws an exception if one by that name already exists.</li>
</ul></ul>
<p>Example:&nbsp; Best practice is to invoke the Repository constructor using <a href="#AllegroGraphServer Class">AllegroGraphServer</a>.getRepository(), which supplies the specialized arguments needed by the Repository contructor.</p>
<pre>    myRepository = catalog.getRepository(&quot;agraph_test&quot;, accessMode)</pre>
<h3>Methods</h3>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
      <td valign="top">addFederatedTripleStores(self, tripleStoreNames)</td>
      <td><p>Make this repository a federated store that includes the stores named in the tuple <em>tripleStoreNames.</em> This call must precede the call to 'initialize'. It<br>
        may be called multiple times.&nbsp; It returns the modified Repository object. </p></td>
  </tr>
  <tr>
      <td valign="top">getConnection(self)</td>
      <td><p>Creates a <a href="#RepositoryConnection Class">RepositoryConnection</a> object that can be used for querying and<br>
        updating the contents of the Repository.&nbsp; Returns the RepositoryConnection object. </p></td>
  </tr>
  <tr>
      <td width="168" valign="top">getDatabaseName(self)</td>
      <td width="591">Returns a string containing the name of this Repository. </td>
  </tr>


  <tr>
      <td valign="top">getValueFactory(self)</td>
      <td>Return a <a href="#ValueFactory Class">ValueFactory</a> for this store.&nbsp; This is present for Aduma Sesame compatibility, but in the Python API all ValueFactory functionality has been duplicated or subsumed in the <a href="#RepositoryConnection Class">RepositoryConnection</a> class.&nbsp; It isn't necessary to manipulate the ValueFactory class at all.&nbsp; </td>
  </tr>
  <tr>
      <td valign="top">indexTriples(self, all=False)</td>
      <td>Indexes the triples of the Repository.&nbsp; <em>All</em> defaults to False; if True it reindexes all triples; if False it indexes only new triples.&nbsp; (Duplicated in the <a href="#RepositoryConnection Class">RepositoryConnection</a> class for Python user convenience.) </td>
  </tr>  <tr>
      <td valign="top">initialize(self)</td>
      <td> A Repository must be initialized before it can be used.&nbsp; Returns the initialized Repository object. </td>
  </tr>
  <tr>
      <td valign="top">isWritable(self)</td>
      <td> Checks whether this Repository is writable, i.e. if the data contained in this store can be changed. </td>
  </tr>
  <tr>
      <td valign="top">registerDatatypeMapping(self, predicate=None, datatype=None, nativeType=None)</td>
      <td><p>Register an inlined datatype. <em>Predicate</em> is the URI of predicate used in the triple store. <em>Datatype</em> may be one of: XMLSchema.INT, XMLSchema.LONG, XMLSchema.FLOAT, XMLSchema.DATE, and XMLSchema.DATETIME.&nbsp; <em>NativeType</em> may be &quot;int&quot;, &quot;datetime&quot;, or &quot;float&quot;.</p>
              <p> You must supply <em>nativeType</em> and either <em>predicate</em> or <em>datatype</em>. </p>
              <p>If <em>predicate</em>, then object arguments to triples with that predicate will use an inlined encoding of type <em>nativeType</em> in their internal representation. If <em>datatype</em>, then typed literal objects with a datatype matching <em>datatype</em> will use an inlined encoding of type <em>nativeType</em>. (Duplicated in the <a href="#RepositoryConnection Class">RepositoryConnection</a> class for Python user convenience.) </p></td>
  </tr>
  <tr>
      <td valign="top">registerFreeTextPredicate(self, uri=None, namespace=None, localname=None)</td>
      <td>You must supply either the<em> uri</em> parameter or both <em>namespace</em> and <em>localname</em>. Register a predicate <em>uri</em> (or alternately generate the URI by concatenating <em>namespace</em>+<em>localname</em>).&nbsp; This tells the Repository to index text keywords from string values of this predicate in the triple store. This makes text search possible on this predicate. (Duplicated in the <a href="#RepositoryConnection Class">RepositoryConnection</a> class for Python user convenience.) </td>
  </tr>
  <tr>
      <td valign="top">shutdown(self)</td>
      <td><p>Shuts the Repository down, releasing any resources that it keeps hold of.<br>
        Once shut down, the store can no longer be used.</p></td>
  </tr>
</table>
<h2 id="RepositoryConnection Class">RepositoryConnection Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The RepositoryConnection class is the main interface for updating data in and performing queries on a <a href="#Repository Class">Repository</a>. By default, a RespositoryConnection is in autoCommit mode, meaning  that each operation corresponds to a single transaction on the underlying triple store. autoCommit can be switched off, in which case it is up to the user to  handle transaction commit/rollback. Note that care should be taking to always  properly close a RepositoryConnection after one is finished with it, to free  up resources and avoid unnecessary locks.<br>
  <br>
  Several methods take a <em>vararg</em> argument that optionally specifies a (set of)  context(s) on which the method should operate. Note that a <em>vararg</em> parameter  is optional, it can be completely left out of the method call, in which case  a method either operates on a provided statements context (if one of the  method parameters is a statement or collection of statements), or operates on  the repository as a whole, completely ignoring context. A <em>vararg</em> argument may  also be null (cast to Resource) meaning that the method operates on those  statements which have no associated context only.</p>
<p>Source: \AllegroGraphDirectory\python\franz\openrdf\repository\repositoryconnection.py.</p>
<h3>Constructor</h3>
<p>RepositoryConnection(self, repository)</p>
<p>where <em>repository</em> is the <a href="#Repository Class">Repository</a> object that created this RepositoryConnection. </p>
<p>Example: The best practice is to use the <a href="#Repository Class">Repository</a>.getConnection() method, which supplies the <em>repository</em> parameter to the construction method. .</p>
<pre>&nbsp;&nbsp;&nbsp; connection = myRepository.getConnection()</pre>
<h3>Methods</h3>
<table width="792" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
      <td valign="top">add(self, arg0, arg1=None, arg2=None, contexts=None, base=None, format=None, serverSide=False)</td>
      <td><p>Calls addTriple(), addStatement(), or addFile(). Best practice is to avoid add() and use addFile(), addStatement(), and addTriple() instead.&nbsp; </p>
              <p><em>arg0</em> may be a <a href="#Statement Class">Statement</a> or a <em>filepath</em>. If so, <em>arg1</em> and <em>arg2</em> default to None. </p>
              <p><em>arg0, arg1</em>, and <em>arg2</em> may be the subject, predicate and object of a single triple. </p>
              <p><em>contexts</em> is an optional list of contexts, defaulting to None.&nbsp; If None, the triple(s) will be added to the null context. </p>
              <p><em>base</em> is the baseURI to associate with loading a file.&nbsp; Defaults to None. </p>
              <p><em>format</em> is RDFFormat.NTRIPLES or RDFFormat.RDFXML. Defaults to None.</p>
              <p><em>serverSide</em> indicates whether the <em>filepath</em> refers to a file on the client computer or on the server.&nbsp; Defaults to False. </p></td>
  </tr>
  <tr>
      <td valign="top">addFile(self, filePath, base=None, format=None, context=None, serverSide=False)</td>
      <td><p>Loads a file into the triple store. Note that a file can be loaded into only one context. </p>
              <p><em>filepath</em> identifies the file to load. </p>
              <p><em>context</em> is an optional context name, defaulting to None.&nbsp; If None, the triple(s) will be added to the null context. </p>
              <p><em>base</em> is the baseURI to associate with loading a file.&nbsp; Defaults to None. </p>
              <p><em>format</em> is RDFFormat.NTRIPLES or RDFFormat.RDFXML. Defaults to None.</p>
              <p><em>serverSide</em> indicates whether the <em>filepath</em> refers to a file on the client computer or on the server.&nbsp; Defaults to False. </p></td>
  </tr>
  <tr>
      <td valign="top">addRules(self, rules, language=None)</td>
      <td>Add a sequence of one or more rules (in ASCII format) to the current environment.<br>
    If the <em>language</em> is QueryLanguage.PROLOG, rule declarations start with '&lt;-' or '&lt;--'. The former appends a new rule; the latter overwrites any rule with the same predicate. <em>language</em> defaults to QueryLanguage.PROLOG. </td>
  </tr>
  <tr>
      <td valign="top">addStatement(self, statement, contexts=None)</td>
      <td>Add the supplied <em><a href="#Statement Class">Statement</a></em> to the specified <em>contexts</em> of the repository.&nbsp; <em>contexts</em> defaults to None, which adds the statement to the null context. . </td>
  </tr>
  <tr>
      <td valign="top">addTriple(self, subject, predicate, object, contexts=None)</td>
      <td>Adds a single triple to the repository.&nbsp; <em>subject, predicate</em> and <em>object</em> are the three values of the triple. <em>contexts </em>is an optional list of contexts to add the triple to, defaulting to None.&nbsp; If None, the triple will be added to the null context. </td>
  </tr>
  <tr>
      <td valign="top">addTriples(self, triples_or_quads, context=ALL_CONTEXTS, ntriples=False)</td>
      <td>Add the supplied <em>triples_or_quads</em> to this repository. Each triple can be a list or a tuple of Values. If <em>context</em> is set, then the context is substituted in for each triple, defaulting to ALL_CONTEXTS. If <em>ntriples</em> is True, then the triples or quads are assumed to contain valid ntriples strings, and they are passed to the server with no conversion. The default value is False. </td>
  </tr>
  <tr>
      <td valign="top">clear(self, contexts=None)</td>
      <td>Removes all statements from the designated <em>contexts</em> in the repository. If<br>
              <em>contexts</em> is None (the default), it clears the repository of all statements. </td>
  </tr>
  <tr>
      <td valign="top">clearNamespaces(self)</td>
      <td>Remove all namespace declarations from the current environment. </td>
  </tr>
  <tr>
      <td width="233" valign="top">close(self)</td>
      <td width="549">Closes the connection in order to free up resources. </td>
  </tr>
  <tr>
      <td valign="top">createBNode(self, nodeID=None)</td>
      <td>Creates a new blank node with the given node identifier. nodeID defaults to None. If <em>nodeID</em> is None, a new, unused node ID is generated. </td>
  </tr>
  <tr>
    <td valign="top">createBox(self, xMin=None, xMax=None, yMin=None, yMax=None)</td>
    <td>Create a rectangular search region (a box) for geospatial search. This method works for both Cartesian and spherical coordinate systems. xMin, xMax may be used to input latitude. yMin, yMax may be used to input longitude.</td>
  </tr>
  <tr>
    <td valign="top">createCircle(self, x, y, radius, unit=None)</td>
    <td>Create a circular search region for geospatial search. This method works for both Cartesian and spherical coordinate systems.<em> radius</em> is the radius of the circle expressed in the designated <em>unit</em>, which defaults to the unit assigned to the coordinate system. <em>x</em> and <em>y</em> locate the center of the circle and may be used for latitude and longitude. </td>
  </tr>
  <tr>
    <td valign="top">createCoordinate(self, x=None, y=None, lat=None, long=None)</td>
    <td>Create a coordinate point in a geospatial coordinate system. Must include <em>x</em> and <em>y</em>, or <em>lat</em> and <em>long.</em> Use this method to create the object value for a location triple. </td>
  </tr>
  <tr>
      <td valign="top">createEnvironment(self, name)</td>
      <td>Repositories use a current environment, which is a container for namespaces and Prolog rules. Rules and namespaces defined in this environment persist across user sessions. Every server-side repository has a default environment that is used when no environment is specified.&nbsp; <em>name</em> is a string label. </td>
  </tr>
  <tr>
    <td valign="top">createLatLongSystem(self, unit='degree', scale=None, latMin=None, latMax=None, longMin=None, longMax=None)</td>
    <td>Create a spherical coordinate system for geospatial location matching. <em>unit</em> can be 'degree', 'mile', 'radian', or 'km'. <em>scale</em> should be your estimate of the size of a typical search region in the latitudinal direction. <em>latMin</em> and <em>latMax</em> are the bottom and top borders of the coordinate system. <em>longMin</em> and <em>longMax</em> are the left and right sides of the coordinate system. </td>
  </tr>
  <tr>
      <td valign="top">createLiteral(self, value, datatype=None, language=None)</td>
      <td>Create a new literal with <em>value</em>. <em>datatype</em> if supplied, should be a URI, in which case <em>value</em> should be a string. You may optionally include an RDF <em>language</em> attribute. <em>datatype </em>and <em>language</em> default to None. </td>
  </tr>
  <tr>
    <td valign="top">createPolygon(self, vertices, uri=None, geoType=None)</td>
    <td>Create a polygonal search region for geospatial search. The vertices are saved as triples in AllegroGraph. <em>vertices</em> is a list of (x, y) pairs such as [(51.0, 2.00),(60.0, -5.0),(48.0,-12.5)]. <em>uri</em> is an optional subject value for the vertex triples, in case you want to manipulate them. <em>geoType</em> is 'CARTESIAN' or 'SPHERICAL', but defaults to None. </td>
  </tr>
  <tr>
      <td valign="top">createRange(self, lowerBound, upperBound)</td>
      <td>Create a compound literal representing a range from <em>lowerBound</em> to <em>upperBound</em>.</td>
  </tr>
  <tr>
    <td valign="top">createRectangularSystem(self, scale=1, unit=None, xMin=0, xMax=None, yMin=0, yMax=None)</td>
    <td>Create a Cartesian coordinate system for geospatial location matching. <em>scale</em> should be your estimate of the Y size of a typical search region. <em>unit </em>must be None. <em>xMin</em> and <em>xMax</em> are the left and right edges of the rectangle. <em>yMin</em> and <em>yMax</em> are the bottom and top edges of the rectangle. </td>
  </tr>
  <tr>
      <td valign="top">createStatement(self, subject, predicate, object, context=None)</td>
      <td>Create a new <a href="#Statement Class">Statement</a> object useing the supplied <em>subject, predicate</em> and <em>object</em><br>
    and associated <em>context</em>, which defaults to None. </td>
  </tr>
  <tr>
      <td valign="top">createURI(self, uri=None, namespace=None, localname=None)</td>
      <td>Creates a new URI object from the supplied string-representation(s). <em>uri</em> is a string representing an entire URI.&nbsp; <em>namespace</em> and <em>localname</em> are combined to create a URI. If two non-keyword arguments are passed, it assumes they represent a<br>
    <em>namespace/localname </em>pair.</td>
  </tr>
  <tr>
      <td valign="top">deleteEnvironment(self, name)</td>
      <td>Delete an environment. This causes all rule and namespace definitions for this<br>
    environment to be lost.</td>
  </tr>
  <tr>
      <td valign="top">deleteRule(self, predicate, language=None)</td>
      <td>Delete rule(s) with predicate named <em>predicate</em>. If <em>predicate</em> is None, delete<br>
    all rules from the current environment. <em>language</em> defaults to QueryLanguage.PROLOG.</td>
  </tr>
  <tr>
      <td valign="top">export(self, handler, contexts=ALL_CONTEXTS)</td>
      <td>Exports all triples in the repository to an external file.&nbsp; <em>handler</em> is either an NTriplesWriter() object or an RDFXMLWriter() object.&nbsp; The export may be optionally confined to a list of <em>contexts</em> (default is ALL_CONTEXTS). </td>
  </tr>
  <tr>
      <td valign="top">exportStatements(self, subj, pred, obj, includeInferred, handler, contexts=ALL_CONTEXTS)</td>
      <td>Exports all triples that match <em>subj</em>, <em>pred</em> and/or <em>obj</em>. &nbsp; May optionally <em>includeInferred</em> statements provided by RDF++ inference (default is False). <em>handler</em> is either an NTriplesWriter() object or an RDFXMLWriter() object.&nbsp; The export may be optionally confined to a list of <em>contexts</em> (default is ALL_CONTEXTS).</td>
  </tr>
  <tr>
      <td valign="top">getContextIDs(self)</td>
      <td>Return a list of context resources, one for each context referenced by a quad in <br>
    the triple store. Omits the default context.</td>
  </tr>
  <tr>
      <td valign="top">getJDBCStatements(self, subject, predicate,  object, contexts=ALL_CONTEXTS, includeInferred=False)</td>
      <td>Gets all statements with a specific <em>subject</em>, <em>predicate</em> and/or <em>object</em> from<br>
    the repository. The result is optionally restricted to the specified set<br>
    of named <em>contexts</em> (default is ALL_CONTEXTS). May optionally <em>includeInferred</em> statements provided by RDF++ inference (default is False). Returns a JDBCResultSet that enables Values, strings, etc. to be selectively extracted from the result, without the bulky overhead of the OpenRDF BindingSet protocol. </td>
  </tr>
  <tr>
      <td valign="top">getNamespace(self, prefix)</td>
      <td>Returns the namespace that is associated with <em>prefix</em>, if any. </td>
  </tr>
  <tr>
      <td valign="top">getNamespaces(self)</td>
      <td>Returns a Python dictionary of prefix/namespace pairings. The default namespaces are: rdf, rdfs, xsd, owl, fti, dc, and dcterms. </td>
  </tr>
  <tr>
      <td valign="top">getStatements(self, subject, predicate,  object, contexts=ALL_CONTEXTS, includeInferred=False,<br>
limit=None)</td>
      <td>Gets all statements with a specific <em>subject</em>, <em>predicate</em> and/or <em>object</em> from the repository. The result is optionally restricted to the specified set of named <em>contexts</em> (default is ALL_CONTEXTS). Returns a <a href="#RepositoryResult Class">RepositoryResult</a> iterator that produces a '<a href="#Statement Class">Statement</a>' each time that 'next' is called. May optionally <em>includeInferred</em> statements provided by RDF++ inference (default is False). Takes an optional <em>limit</em> on the number of statements to return.&nbsp; </td>
  </tr>
  <tr>
    <td valign="top">getStatementsById(self, ids) </td>
    <td>Return all statements whose triple ID matches an ID in the list of <em>ids.</em> </td>
  </tr>
  <tr>
    <td valign="top">getValueFactory(self)</td>
    <td>Returns the <a href="#ValueFactory Class">ValueFactory</a> object associated with this RepositoryConnection. </td>
  </tr>
  <tr>
      <td valign="top">indexTriples(self, all=False)</td>
      <td>Indexes the triples of the repository.&nbsp; <em>All</em> defaults to False; if True it reindexes all triples; if False it indexes only new triples.</td>
  </tr>
  <tr>
      <td valign="top">isEmpty(self)</td>
      <td>Returns True if size() is zero.&nbsp; </td>
  </tr>
  <tr>
      <td valign="top">listEnvironments(self)</td>
      <td>List the names of environments currently maintained by the system.</td>
  </tr>
  <tr>
      <td valign="top">loadRules(self, file ,language=None)</td>
      <td>Load a file of rules into the current environment. <em>file</em> is assumed to reside on the client machine. <em>language</em> defaults to QueryLanguage.PROLOG.</td>
  </tr>
  <tr>
      <td valign="top">prepareBooleanQuery(self, queryLanguage, queryString, baseURI=None)</td>
      <td>Parse <em>queryString</em> into a <a href="#Query Class">Query</a> object which can be executed against the RDF storage. <em>queryString</em> must be an ASK query. The result is true or false. <em>queryLanguage</em> is one of SPARQL, PROLOG, or COMMON_LOGIC.&nbsp; <em>baseURI</em> optionally provides a URI prefix (defaults to None). Returns a <a href="#Query Class">Query</a> object.&nbsp; The result of query execution will be True of False. </td>
  </tr>
  <tr>
      <td valign="top">prepareGraphQuery(self, queryLanguage, queryString, baseURI=None)</td>
      <td>Parse <em>queryString</em> into a <a href="#Query Class">Query</a> object which can be executed against the RDF storage. <em>queryString</em> must be a CONSTRUCT or DESCRIBE query. <em>queryLanguage</em> is one of SPARQL, PROLOG, or COMMON_LOGIC.&nbsp; <em>baseURI</em> optionally provides a URI prefix (defaults to None). Returns a <a href="#Query Class">Query</a> object. The result of query execution is an iterator of <a href="#Statement Class">Statement</a>s/quads.</td>
  </tr>
  <tr>
      <td valign="top">prepareTupleQuery(self, queryLanguage, queryString, baseURI=None)</td>
      <td>Embed <em>queryString</em> into a <a href="#Query Class">Query</a> object which can be executed against the RDF storage. <em>queryString</em> must be a SELECT query. <em>queryLanguage</em> is one of SPARQL, PROLOG, or COMMON_LOGIC.&nbsp; <em>baseURI</em> optionally provides a URI prefix (defaults to None). Returns a <a href="#Query Class">Query</a> object. The result of query execution is an iterator of tuples.</td>
  </tr>
  <tr>
      <td valign="top">registerDatatypeMapping(self, predicate=None, datatype=None, nativeType=None)</td>
      <td><p>Register an inlined datatype. <em>Predicate</em> is the URI of predicate used in the triple store. <em>Datatype</em> may be one of: XMLSchema.INT, XMLSchema.LONG, XMLSchema.FLOAT, XMLSchema.DATE, and XMLSchema.DATETIME.&nbsp; <em>NativeType</em> may be &quot;int&quot;, &quot;datetime&quot;, or &quot;float&quot;.</p>
              <p> You must supply <em>nativeType</em> and either <em>predicate</em> or <em>datatype</em>. </p>
              <p>If <em>predicate</em>, then object arguments to triples with that predicate will use an inlined encoding of type <em>nativeType</em> in their internal representation. If <em>datatype</em>, then typed literal objects with a datatype matching <em>datatype</em> will use an inlined encoding of type <em>nativeType</em>.</p></td>
  </tr>
  <tr>
      <td valign="top">registerFreeTextPredicate(self, uri=None, namespace=None, localname=None)</td>
      <td>You must supply either the<em> uri</em> parameter or both <em>namespace</em> and <em>localname</em>. Register a predicate <em>uri</em> (or alternately generate the URI by concatenating <em>namespace</em>+<em>localname</em>).&nbsp; This tells the <a href="#Repository Class">Repository</a> to index text keywords from string values of this predicate in the triple store. This makes text search possible on this predicate. </td>
  </tr>
  <tr>
      <td valign="top">remove(self, arg0, arg1=None, arg2=None, contexts=None)</td>
      <td><p>Calls removeTriples() or removeStatement().&nbsp; Best practice would be to avoid remove() and use removeTriples() or removeStatement() directly. </p>
              <p><em>arg0</em> may be a <a href="#Statement Class">Statement</a>.&nbsp; If so, then <em>arg1</em> and <em>arg2</em> default to None. </p>
              <p><em>arg0, arg1</em>, and <em>arg2</em> may be the subject, predicate and object of a triple.</p>
              <p><em>contexts</em> is an optional list of contexts, defaulting to None. </p></td>
  </tr>
  <tr>
      <td valign="top">removeNamespace(self, prefix)</td>
      <td>Remove the namespace associate with <em>prefix</em>. </td>
  </tr>
  <tr>
      <td valign="top">removeQuads(self, quads, ntriples=False)</td>
      <td>Remove enumerated quads from this repository. Each <em>quad</em> can be a list or a tuple of Values. If <em>ntriples</em> is True (default is False), then the quads are assumed to contain valid ntriples strings, and they are passed to the server with no conversion. </td>
  </tr>
  <tr>
    <td valign="top">removeQuadsByID(self, tids)</td>
    <td><em>tids</em> contains a list of triple IDs (integers). Remove all quads with IDs that match. </td>
  </tr>
  <tr>
      <td valign="top">removeStatement(self, statement, contexts=None)</td>
      <td>Removes the supplied <em><a href="#Statement Class">Statement</a></em>(s) from the specified <em>contexts</em> (default is None). </td>
  </tr>
  <tr>
      <td valign="top">removeTriples(self, subject, predicate, object, contexts=None)</td>
      <td>Removes the triples with the specified <em>subject</em>, <em>predicate</em> and <em>object</em><br>
    from the repository, optionally restricted to the specified <em>contexts</em> (defaults to None)..</td>
  </tr>
  <tr>
      <td valign="top">setEnvironment(self, name)</td>
      <td>Choose an environment for execution of a Prolog query. Call deleteEnvironment() to start with a fresh (empty) environment.</td>
  </tr>
  <tr>
      <td valign="top">setNamespace(self, prefix, namespace)</td>
      <td>Define (or redefine) a <em>namespace</em> associated with <em>prefix</em>. </td>
  </tr>
  <tr>
      <td valign="top">setRuleLanguage(self, queryLanguage)</td>
      <td><em>queryLanguage</em> is QueryLanguage.PROLOG.</td>
  </tr>
  <tr>
      <td valign="top">size(self, contexts=ALL_CONTEXTS)</td>
      <td>Returns the number of (explicit) statements that are in the specified <em>contexts</em> in this repository. contexts defaults to ALL_CONTEXTS, but can be a tuple of context names from getContextIDs(). </td>
  </tr>
</table>
<h2 id="Query Class">Query Class&nbsp;(and Subclasses) &nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The Query class is 


non-instantiable. It is an abstract class from which the three query subclasses are derived.&nbsp; It is included here because of its methods, which are inherited by the subclasses.&nbsp; </p>
<p>A query on a <a href="#Repository Class">Repository</a> that can be formulated in one of the 
    supported query languages (for example SPARQL). It allows one to 
    predefine bindings in the query to be able to reuse the same query with 
    different bindings. &nbsp; </p>
<p>Source: \AllegroGraphDirectory\python\franz\openrdf\query\query.py.</p>
<h3>Constructor</h3>
<p>Query(self, queryLanguage, queryString, baseURI=None)</p>
<ul>
    <li><em>queryLanguage </em>is one of &quot;queryLanguage.SPARQL&quot;, &quot;queryLanguage.PROLOG&quot;, or &quot;queryLanguage.COMMON_LOGIC.&quot; </li>
    <li><em>queryString</em> is the text of a query in the appropriate language.</li>
    <li><em>baseURI</em>  optionally provides a URI prefix (defaults to None).</li>
</ul>
<p>Example:&nbsp; Best practice is to allow the <a href="#RepositoryConnection Class">RepositoryConnection</a> object to create an instance of one of the Query subclasses (<a href="#Subclass TupleQuery">TupleQuery</a>, <a href="#Subclass GraphQuery">GraphQuery</a>, <a href="#Subclass BooleanQuery">BooleanQuery</a>). There is no reason for the Python application programmer to create a Query object directly.&nbsp; </p>
<pre>   tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)
   result = tupleQuery.evaluate();</span>)</pre>
<h3>Methods</h3>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
      <td valign="top">evaluate_generic_query(self)</td>
      <td>Evaluate a SPARQL or PROLOG or COMMON_LOGIC query. If SPARQL, it may be a 'select', 'construct', 'describe' or 'ask' query. Return an appropriate response. (Best practice is to use (and evaluate) one of the more specific query subclasses.)&nbsp; </td>
  </tr>
    <tr>
      <td valign="top">getBindings(self)</td>
      <td>Retrieves the bindings that have been set on this query in the form of a dictionary. </td>
  </tr>
    <tr>
      <td valign="top">getDataset(self)</td>
      <td>Returns the current dataset setting for this query. </td>
  </tr>
    <tr>
      <td valign="top">getIncludeInferred(self)</td>
      <td>Returns whether or not this query will return inferred statements (if any<br>
  are present in the repository).</td>
  </tr>
    <tr>
      <td valign="top">removeBinding(self, name)</td>
      <td><p>Removes the named binding so that it has no value.</p></td>
  </tr>
    <tr>
      <td width="168" valign="top">setBinding(self, name, value)</td>
      <td width="591">Binds the named attribute to the supplied value. Any value that was previously bound to the specified attribute will be overwritten. </td>
  </tr>
    <tr>
      <td valign="top">setBindings(self, dict)</td>
      <td>Sets multiple bindings using a dictionary of attribute names and values. </td>
  </tr>
    <tr>
      <td valign="top">setCheckVariables(self, setting)</td>
      <td> If true, the presence of variables in the SELECT clause not referenced in a triple pattern <br>
  are flagged.</td>
  </tr>
    <tr>
      <td valign="top">setContexts(self, contexts)</td>
      <td>Assert a set of contexts (named graphs) that filter all triples.</td>
  </tr>
    <tr>
      <td valign="top">setDataset(self, dataset)</td>
      <td>Specifies the dataset against which to evaluate a query, overriding any dataset that is specified in the query itself.</td>
  </tr>
    <tr>
      <td valign="top">setIncludeInferred(self, includeInferred)</td>
      <td>Determines whether results of this query should include inferred statements (if any inferred statements are present in the repository). The default setting is 'true'.</td>
  </tr>
</table>
<h3 id="Subclass TupleQuery">Subclass TupleQuery&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a> </h3>
<p>This subclass is used with SELECT queries.&nbsp; Use the <a href="#RepositoryConnection Class">RepositoryConnection</a> object's <strong>prepareTupleQuery()</strong> method to create a TupleQuery object. The results of the query are returned in a <a href="#RepositoryResult Class">RepositoryResult</a> iterator that yields a sequence of bindingSets.</p>
<p><strong>Methods</strong></p>
<p>TupleQuery uses all the methods of the <a href="#Query Class">Query</a> class, plus one more: </p>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
        <td valign="top">evaluate(self, jdbc=False)</td>
        <td>Execute the embedded query against the RDF store. Return 
an iterator that produces for each step a tuple of values 
(resources and literals) corresponding to the variables 
or expressions in a 'select' clause (or its equivalent). 
If 'jdbc', returns a JDBC-style iterator that miminizes the 
overhead of creating response objects. </td>
    </tr>
</table>
<h3 id="Subclass GraphQuery">Subclass GraphQuery&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a> </h3>
<p>This subclass is used with CONSTRUCT and DESCRIBE queries.&nbsp; Use the <a href="#RepositoryConnection Class">RepositoryConnection</a> object's <strong>prepareGraphQuery()</strong> method to create a GraphQuery object. The results of the query are returned in a <a href="#RepositoryResult Class">RepositoryResult</a> iterator that yields a sequence of bindingSets.</p>
<p><strong>Methods</strong></p>
<p>GraphQuery uses all the methods of the <a href="#Query Class">Query</a> class, plus one more:</p>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
        <td valign="top">evaluate(self)</td>
        <td>Execute the embedded query against the RDF store.</td>
    </tr>
</table>
<h3 id="Subclass BooleanQuery">Subclass BooleanQuery &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h3>
<p>This subclass is used with ASK queries.&nbsp; Use the <a href="#RepositoryConnection Class">RepositoryConnection</a> object's <strong>prepareBooleanQuery()</strong> method to create a BooleanQuery object. The results of the query are True or False.</p>
<p><strong>Methods</strong></p>
<p>BooleanQuery uses all the methods of the <a href="#Query Class">Query</a> class, plus one more:</p>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
        <td valign="top">evaluate(self)</td>
        <td>Execute the embedded query against the RDF store.</td>
    </tr>
</table>

<h2 id="RepositoryResult Class">RepositoryResult Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>A RepositoryResult object is a result collection of objects (for example, <a href="#Statement Class">Statement</a> objects) that can be iterated over. It  keeps an open connection to the backend for lazy retrieval of individual  results. Additionally it has some utility methods to fetch all results and  add them to a collection.<br>
  <br>
  By default, a RepositoryResult is not necessarily a (mathematical) set: it  may contain duplicate objects. Duplicate filtering can be  switched on,  but this should not be used lightly as the filtering mechanism is potentially  memory-intensive.<br>
  <br>
  A RepositoryResult needs to be closed after use to free up  any resources (open connections, read locks, etc.) it has on the underlying  repository.</p>
<p>Source: \AllegroGraphDirectory\python\franz\openrdf\repository\repositoryresult.py.</p>
<h3>Constructor</h3>
<p>RepositoryResult(self, string_tuples, subjectFilter=None, tripleIDs=False)</p>
<ul>
  <li><em>string_tuples</em> is the payload of search results.</li>
  <li><em>subjectFilter</em> can be used to narrow the results to one resource. </li>
  <li><em>tripleIDs</em> defaults to false.&nbsp; If true, the RepositoryResult object contains the triple IDs of the matching triples. </li>
</ul>
<p>Example:&nbsp; Best practice is to allow a querySubclass.evaluate() method to create and return the RepositoryResult object. There is no reason for the Python application programmer to create a RepositoryResult object directly.&nbsp; </p>
<pre>        tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>        result = tupleQuery.evaluate();</pre>
<h3>Methods</h3>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
        <td width="168" valign="top">close(self)</td>
        <td width="591">Shut down the iterator to be sure the resources are freed up. </td>
    </tr>
    <tr>
        <td valign="top">next(next)</td>
        <td>Return the next <a href="#Statement Class">Statement</a> in the answer, if there is one.</td>
    </tr>
    <tr>
        <td valign="top">enableDuplicateFilter(self)</td>
        <td> Switches on duplicate filtering while iterating over objects. The  RepositoryResult will keep track of the previously returned objects in a  java.util.Set and on calling next() will ignore any  objects that already occur in this Set.<br>            <br>
         Caution: use of this filtering mechanism is potentially memory-intensive.</td>
    </tr>
    <tr>
        <td valign="top">asList(self)</td>
        <td>Returns a list containing all objects of this RepositoryResult in 
order of iteration. The RepositoryResult is fully consumed and 
automatically closed by this operation.</td>
    </tr>
    <tr>
        <td valign="top">addTo(self, collection)</td>
        <td>Adds all objects of this RepositoryResult to the supplied collection. The 
RepositoryResult is fully consumed and automatically closed by this 
operation.</td>
    </tr>
    <tr>
        <td valign="top">rowCount(self)</td>
        <td>Returns the number of result items stored in this object. </td>
    </tr>
</table>
<p>&nbsp;</p>
<h2 id="Statement Class">Statement Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>


<p>A Statement is a client-side triple.&nbsp; It encapsulates the subject, predicate, object and context values of a single triple and makes them available. </p>
<p>Source: \AllegroGraphDirectory\python\franz\openrdf\model\statement.py.</p>
<h3>Constructor</h3>
<p>Statement(self, subject, predicate, object, context=None)</p>
<ul>
  <li><em>subject, predicate, object </em>are the values of a typical triple.</li>
  <li><em>context </em> is the optional label of the context subdivision of the repository.. </li>
</ul>
<p>Example:&nbsp; Best practice is to allow the <a href="#RepositoryConnection Class">RepositoryConnection</a>.createStatement() method to create and return the Statement object. There is no reason for the Python application programmer to create a Statement object directly.&nbsp; </p>
<pre>    stmt1 = conn.createStatement(alice, age, fortyTwo)</pre>
<h3>Methods</h3>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
      <td valign="top">getContext(self)</td>
      <td>Returns the value in the fourth position of the stored tuple. </td>
  </tr>
  <tr>
      <td valign="top">getObject(self)</td>
      <td>Returns the value in the third position of the stored tuple. </td>
  </tr>
  <tr>
      <td valign="top">getPredicate(self)</td>
      <td>Returns the value in the second position of the stored tuple. </td>
  </tr>
  <tr>
      <td valign="top">getSubject(self)</td>
      <td>Returns the value in the first position of the stored tuple. </td>
  </tr>
  <tr>
      <td width="168" valign="top">setQuad(self, string_tuple)</td>
      <td width="591"><p>Stores a string_tuple of a triple or quad.&nbsp; This method is called only by an internal method of the <a href="#RepositoryResult Class">RepositoryResult</a> class.&nbsp; There is no need for a Python application programmer to use it. </p></td>
  </tr>
</table>
<p>&nbsp;</p>
<h2 id="ValueFactory Class">ValueFactory Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>A ValueFactory is a factory for creating URIs, blank nodes, literals and <a href="#Statement Class">Statement</a>s.&nbsp; In the AllegroGraph Python interface, the ValueFactory class would be regarded as obsolete.&nbsp; Its functions have been subsumed by the expanded capability of the ResponseConnection class. It is documented here for the convenience of the person who is porting an application from Aduma Sesame. &nbsp; </p>
<p>Source: \AllegroGraphDirectory\python\franz\openrdf\model\valuefactory.py.</p>
<h3>Constructor</h3>
<p>ValueFactory(self, store)</p>
<ul>
    <li><em>store </em>is the <a href="#Repository Class">Repository</a> object that generated this ValueFactory.</li>
</ul>
<p>Example:&nbsp; Best practice is to allow the <a href="#Repository Class">Repository</a> constructor to generate the ValueFactory automatically at the same time that the Repository object is created.&nbsp; There is no reason for a Python application programmer to attempt this step manually.&nbsp; </p>
<h3>Methods</h3>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
        <td width="168" valign="top">createBNode()</td>
        <td width="591"><p>See <a href="#RepositoryConnection Class">RepositoryConnection</a> class. &nbsp; </p></td>
    </tr>
    <tr>
        <td valign="top">createLiteral()</td>
        <td>See <a href="#RepositoryConnection Class">RepositoryConnection</a> class. &nbsp;</td>
    </tr>
    <tr>
        <td valign="top">createStatement()</td>
        <td>See <a href="#RepositoryConnection Class">RepositoryConnection</a> class. </td>
    </tr>
    <tr>
        <td valign="top">createURI()</td>
        <td>See <a href="#RepositoryConnection Class">RepositoryConnection</a> class. </td>
    </tr>
</table>
<p></p>
<p>&nbsp;  </p>
</body>

